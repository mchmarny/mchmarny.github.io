<!doctype html><html lang=en dir=auto data-theme=dark><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Complexity can be learned but abstractions come at a long-term cost | Mark Chmarny</title><meta name=keywords content="complexity,cost,oss"><meta name=description content="All complexity needs to be abstracted, right? This reductionist statements misses nuance around the inherent cost/benefit tradeoffs, especially when you consider these over time.
Don’t get me wrong, there often are good reasons for additional layers to make things simpler (grow adoption, lowering toil, removing friction, etc.). Still, these layers come at the long-term cost that’s often is not a part of the evaluation process."><meta name=author content="Mark Chmarny"><link rel=canonical href=https://blog.chmarny.com/posts/complexity-can-be-learned-but-abstractions-come-at-long-term-cost/><link crossorigin=anonymous href=/assets/css/stylesheet.5bef4b698d33ee9d58f22269d129fe3c725b1b3356a4ed1ded10651b773f88c5.css integrity="sha256-W+9LaY0z7p1Y8iJp0Sn+PHJbGzNWpO0d7RBlG3c/iMU=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chmarny.com/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chmarny.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chmarny.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chmarny.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.chmarny.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chmarny.com/posts/complexity-can-be-learned-but-abstractions-come-at-long-term-cost/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><meta property="og:url" content="https://blog.chmarny.com/posts/complexity-can-be-learned-but-abstractions-come-at-long-term-cost/"><meta property="og:site_name" content="Mark Chmarny"><meta property="og:title" content="Complexity can be learned but abstractions come at a long-term cost"><meta property="og:description" content="All complexity needs to be abstracted, right? This reductionist statements misses nuance around the inherent cost/benefit tradeoffs, especially when you consider these over time.
Don’t get me wrong, there often are good reasons for additional layers to make things simpler (grow adoption, lowering toil, removing friction, etc.). Still, these layers come at the long-term cost that’s often is not a part of the evaluation process."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-30T19:35:48+00:00"><meta property="article:modified_time" content="2021-03-30T19:35:48+00:00"><meta property="article:tag" content="Complexity"><meta property="article:tag" content="Cost"><meta property="article:tag" content="Oss"><meta property="og:image" content="https://blog.chmarny.com/images/site-feature-image.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.chmarny.com/images/site-feature-image.png"><meta name=twitter:title content="Complexity can be learned but abstractions come at a long-term cost"><meta name=twitter:description content="All complexity needs to be abstracted, right? This reductionist statements misses nuance around the inherent cost/benefit tradeoffs, especially when you consider these over time.
Don’t get me wrong, there often are good reasons for additional layers to make things simpler (grow adoption, lowering toil, removing friction, etc.). Still, these layers come at the long-term cost that’s often is not a part of the evaluation process."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chmarny.com/posts/"},{"@type":"ListItem","position":2,"name":"Complexity can be learned but abstractions come at a long-term cost","item":"https://blog.chmarny.com/posts/complexity-can-be-learned-but-abstractions-come-at-long-term-cost/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Complexity can be learned but abstractions come at a long-term cost","name":"Complexity can be learned but abstractions come at a long-term cost","description":"All complexity needs to be abstracted, right? This reductionist statements misses nuance around the inherent cost/benefit tradeoffs, especially when you consider these over time.\nDon’t get me wrong, there often are good reasons for additional layers to make things simpler (grow adoption, lowering toil, removing friction, etc.). Still, these layers come at the long-term cost that’s often is not a part of the evaluation process.\n","keywords":["complexity","cost","oss"],"articleBody":"All complexity needs to be abstracted, right? This reductionist statements misses nuance around the inherent cost/benefit tradeoffs, especially when you consider these over time.\nDon’t get me wrong, there often are good reasons for additional layers to make things simpler (grow adoption, lowering toil, removing friction, etc.). Still, these layers come at the long-term cost that’s often is not a part of the evaluation process.\nTake for example the complexity around Kubernetes (it seems to be an easy target nowadays).\nWhile improving the user experience in specific use-case there, you are de-facto taking on the responsibility for maintenance of that abstraction over time.\nIs that value (ease of use for your specific use-case) higher than that responsibility? If your use-case is more common, you may be thinking about open-sourcing that abstraction to offset that cost. Just ask those who created OSS projects before, that cost is usually multiple of that associated with managing your own “custom solution”.\nMore importantly, perhaps, you have to ask yourself if that compounded cost is lower than the cognitive load required to learn how to use the current implementation.\nIs that a one time cost that users, once learn, apply over time? Or is that just replacement of one thing the user has to learn with another? The Kubernetes landscape is full of carcasses of well-intended projects aiming to solve its complexity. Their relevance usually ends by either being outpaced by the community, or acquiring an even higher cognitive load. Another cost which perhaps is not always consider when hiding complexity is the potential for decreased portability. This can be due to the fact that the resulting implementation, lacking broad adoption, is simply not available in the target platform. Or, the decreased portability may also be related to the implementation “leaking” into the user space, making that application now dependent on that abstraction.\nAgain, there are many examples where abstractions of complexity delivers a lot of value. Often that value is broadly recognized, and it becomes either upstreamed to address the root complexity (e.g. kustomize in kubectl), or it becomes part fo the broader community cannon (e.g. CNCF projects) around the project.\nThe points I’m trying to make here is this:\nEvaluate the broader and long-term cost/value trade-offs of abstracting complexity Consider addressing that complexity at its root, rather than abstraction And, most importantly, don’t underestimate users’ ability to learn! ","wordCount":"395","inLanguage":"en","image":"https://blog.chmarny.com/images/site-feature-image.png","datePublished":"2021-03-30T19:35:48.769Z","dateModified":"2021-03-30T19:35:48.769Z","author":{"@type":"Person","name":"Mark Chmarny"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chmarny.com/posts/complexity-can-be-learned-but-abstractions-come-at-long-term-cost/"},"publisher":{"@type":"Organization","name":"Mark Chmarny","logo":{"@type":"ImageObject","url":"https://blog.chmarny.com/favicons/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://blog.chmarny.com/ accesskey=h title="Mark Chmarny (Alt + H)">Mark Chmarny</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chmarny.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://blog.chmarny.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.chmarny.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.chmarny.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.chmarny.com/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.chmarny.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.chmarny.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Complexity can be learned but abstractions come at a long-term cost</h1><div class=post-meta><span title='2021-03-30 19:35:48.769 +0000 UTC'>2021-03-30</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>Mark Chmarny</span></div></header><div class=post-content><p>All complexity needs to be abstracted, right? This reductionist statements misses nuance around the inherent cost/benefit tradeoffs, especially when you consider these over time.</p><p>Don’t get me wrong, there often are good reasons for additional layers to make things simpler (grow adoption, lowering toil, removing friction, etc.). Still, these layers come at the long-term cost that’s often is not a part of the evaluation process.</p><p>Take for example the complexity around Kubernetes (it seems to be an <a href=https://twitter.com/jbeda/status/993978918196531200>easy target</a> nowadays).</p><blockquote><p>While improving the user experience in specific use-case there, you are de-facto taking on the responsibility for maintenance of that abstraction over time.</p></blockquote><p>Is that value (ease of use for your specific use-case) higher than that responsibility? If your use-case is more common, you may be thinking about open-sourcing that abstraction to offset that cost. Just ask those who created OSS projects before, that cost is usually multiple of that associated with managing your own &ldquo;custom solution&rdquo;.</p><blockquote><p>More importantly, perhaps, you have to ask yourself if that compounded cost is lower than the cognitive load required to learn how to use the current implementation.</p></blockquote><img style=width:200px;height:200px align=right src=/images/1__KcpNGlOGHu8__c9i0wslOQQ.png>
Is that a one time cost that users, once learn, apply over time? Or is that just replacement of one thing the user has to learn with another? The Kubernetes landscape is full of carcasses of well-intended projects aiming to solve its complexity. Their relevance usually ends by either being outpaced by the community, or acquiring an even higher cognitive load.<p>Another cost which perhaps is not always consider when hiding complexity is the potential for decreased portability. This can be due to the fact that the resulting implementation, lacking broad adoption, is simply not available in the target platform. Or, the decreased portability may also be related to the implementation &ldquo;leaking&rdquo; into the user space, making that application now dependent on that abstraction.</p><p>Again, there are many examples where abstractions of complexity delivers a lot of value. Often that value is broadly recognized, and it becomes either upstreamed to address the root complexity (e.g. <a href=https://kustomize.io/>kustomize</a> in <a href=https://kubernetes.io/docs/tasks/manage-kubernetes-objects/kustomization/>kubectl</a>), or it becomes part fo the broader community cannon (e.g. <a href=https://www.cncf.io/projects/>CNCF projects</a>) around the project.</p><p>The points I’m trying to make here is this:</p><ul><li>Evaluate the broader and long-term cost/value trade-offs of abstracting complexity</li><li>Consider addressing that complexity at its root, rather than abstraction</li><li>And, most importantly, don’t underestimate users’ ability to learn!</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chmarny.com/tags/complexity/>Complexity</a></li><li><a href=https://blog.chmarny.com/tags/cost/>Cost</a></li><li><a href=https://blog.chmarny.com/tags/oss/>Oss</a></li></ul><nav class=paginav><a class=prev href=https://blog.chmarny.com/posts/custom-news-scraper-using-free-services-from-github-firebase-sengrid/><span class=title>« Prev</span><br><span>Custom news scraper using free services from GitHub, Firebase, and Sengrid</span>
</a><a class=next href=https://blog.chmarny.com/posts/how-i-learned-dapr-building-tweet-sentiment-processing-pipeline/><span class=title>Next »</span><br><span>How I learned Dapr building tweet sentiment processing pipeline</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://blog.chmarny.com/>Mark Chmarny</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>