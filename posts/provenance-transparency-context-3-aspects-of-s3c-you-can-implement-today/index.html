<!doctype html><html lang=en dir=auto data-theme=dark><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Provenance, transparency, and context, the three aspects of software supply chain security you can implement today | Mark Chmarny</title><meta name=keywords content="s3c,sbom,cve,slsa,sbom,vex"><meta name=description content="The practice of Secure Software Supply Chain (S3C) can get complex at times. Fortunately though, a large portion of the key things we can do to secure our software delivery pipelines are actually pretty easy. This post covers three concepts you can implement today:"><meta name=author content="Mark Chmarny"><link rel=canonical href=https://blog.chmarny.com/posts/provenance-transparency-context-3-aspects-of-s3c-you-can-implement-today/><link crossorigin=anonymous href=/assets/css/stylesheet.5bef4b698d33ee9d58f22269d129fe3c725b1b3356a4ed1ded10651b773f88c5.css integrity="sha256-W+9LaY0z7p1Y8iJp0Sn+PHJbGzNWpO0d7RBlG3c/iMU=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chmarny.com/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chmarny.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chmarny.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chmarny.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.chmarny.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chmarny.com/posts/provenance-transparency-context-3-aspects-of-s3c-you-can-implement-today/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><meta property="og:url" content="https://blog.chmarny.com/posts/provenance-transparency-context-3-aspects-of-s3c-you-can-implement-today/"><meta property="og:site_name" content="Mark Chmarny"><meta property="og:title" content="Provenance, transparency, and context, the three aspects of software supply chain security you can implement today"><meta property="og:description" content="The practice of Secure Software Supply Chain (S3C) can get complex at times. Fortunately though, a large portion of the key things we can do to secure our software delivery pipelines are actually pretty easy. This post covers three concepts you can implement today:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-14T08:57:57-07:00"><meta property="article:modified_time" content="2023-06-14T08:57:57-07:00"><meta property="article:tag" content="S3c"><meta property="article:tag" content="Cve"><meta property="article:tag" content="Slsa"><meta property="article:tag" content="Sbom"><meta property="article:tag" content="Vex"><meta property="og:image" content="https://blog.chmarny.com/images/site-feature-image.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.chmarny.com/images/site-feature-image.png"><meta name=twitter:title content="Provenance, transparency, and context, the three aspects of software supply chain security you can implement today"><meta name=twitter:description content="The practice of Secure Software Supply Chain (S3C) can get complex at times. Fortunately though, a large portion of the key things we can do to secure our software delivery pipelines are actually pretty easy. This post covers three concepts you can implement today:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chmarny.com/posts/"},{"@type":"ListItem","position":2,"name":"Provenance, transparency, and context, the three aspects of software supply chain security you can implement today","item":"https://blog.chmarny.com/posts/provenance-transparency-context-3-aspects-of-s3c-you-can-implement-today/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Provenance, transparency, and context, the three aspects of software supply chain security you can implement today","name":"Provenance, transparency, and context, the three aspects of software supply chain security you can implement today","description":"The practice of Secure Software Supply Chain (S3C) can get complex at times. Fortunately though, a large portion of the key things we can do to secure our software delivery pipelines are actually pretty easy. This post covers three concepts you can implement today:\n","keywords":["s3c","sbom","cve","slsa","sbom","vex"],"articleBody":"The practice of Secure Software Supply Chain (S3C) can get complex at times. Fortunately though, a large portion of the key things we can do to secure our software delivery pipelines are actually pretty easy. This post covers three concepts you can implement today:\nprovenance - Where and how was the software created? Using what source code, tools, and build system? Who were the individuals involved in its development? transparency - What’s in the software artifact? What are the packages, libraries, and their versions? Who provided them? And, what are the relationships between them? (what depends on, uses, what) context - What are the vulnerabilities, and what is their potential exploitability in that specific artifact? Let’s review each one of these and provide some options on how to implement them in your software release pipeline.\nProvenance The open source community under OpenSSF has created a security framework for how we can think of build provenance. This framework is called Supply Chain Levels for Software Artifacts (SLSA). it provides a standardized check-list of controls to improve the integrity, prevent tampering, and secure software artifacts and build infrastructure.\nAt its core, SLSA is based on the builders producing conformant and signed provenance documents (aka build attestation). The provenance document includes Build Definition (e.g. parameters, dependencies), and Run Details (e.g. builder, metadata). And, to make it easier for us to reason about it, the key characteristics of the build provenance are grouped into SLSA Levels (1-3). The downstream consumers of the produced artifacts can inspect the provenance, and base their policy decisions on the inferred level of SLSA. More about SLSA levels on slsa.dev.\nAdd SLSA-based build provenance to your release pipeline:\nGoogle Cloud Build - Level 3 assurance automatically generated in Artifact Analysis for all images pushed to Artifact Registry GitHub Actions - Reusable workflow, which when added to your release pipeline generates Level 3 build provenance GitLab CI/CD - Runner which can generate artifact metadata meeting SLSA Level 2 with support for external code signer to potentially deliver Level 3. Regardless of the means by which SLSA provenance was generated, you can use the SLSA Verifier CLI to ensure its validity.\nTransparency While SLSA is about how the software was produced, Software Bill of Materials (SBOM) is about what’s in the software. Think of SBOM like an ingredients label on a can of food you buy in the grocery store. It’s an inventory of all the components that make up the software. SBOMs are used during the production of software (e.g. license compliance), during process of software selection (e.g. policy compliance), or during operations (e.g. risk management). SBOMs can be also used in all three of these use-cases for vulnerability monitoring as new vulnerabilities are discovered all the time. More about SBOM and the related US regulation on cisa.gov/sbom. Similar regulations apply in the EU and the UK. While there is many formats/flavors of SBOM, the most common open standards today are:\nSPDX (Software Package Data Exchange) - Provides a structured format for documenting software components, licenses, copyrights, and security vulnerabilities, including information about packages, files, and relationships. It’s maintained by the Linux Foundation (LF), and it has a broader ecosystem of tools and libraries which can make it easier to integrate into your pipeline. Given the extensive set of fields and options, SPDX can get complex for humans to reason about though. CycloneDX - Provides a lightweight and flexible representation of the components and dependencies, including details about packages, versions, licenses, and vulnerability information, allowing for interoperability between different tools and platforms. CycloneDX allows for extensibility (see VEX section below). However, unlike SPDX, CycloneDX is not an industry-standard format, and while it has gained traction and adoption, it may not enjoy the same level of standardization and industry-wide acceptance as SPDX. Ultimately, the choice between SPDX and CycloneDX depends on your specific needs, the ecosystem you operate in, and the level of standardization and extensibility required for your software supply chain management.\nYou can add SBOM to your release pipeline in a number of ways:\nUsing Lockfile - These SBOMs are generated using the information in language specific lockfile (e.g. go.mod, gradle.lockfile, or pom.xml). Sometimes they are generated by your Source Code Management System (e.g. GitHub SBOM). While easy, this approach does not account only for the user defined code, and lacks information about the base image on which this code will be deployed. Lockfile-based SBOMs don’t work well also for repos which build to more than one artifact. During Build - Generating SBOMs during build is not very common yet. For the Go ecosystem, there is ko, and for Java Maven using the CycloneDX plugin. The benefit of this approach is build tools have a deep understanding of the dependencies, and the SBOM generation becomes this way an inherent part of the build workflow, ensuring consistency with each build (e.g. format) From Container - These SBOMs are generated from the final product. This is the most common approach to generating SBOMs today (e.g. using OSS tools like syft or snyk). The reliance on the layered file systems or container image may result in an incomplete view of all the dependencies, especially with transitive dependencies and in situations when not installed using package manager. Context Unless you are building a simple hello world application, chances are high you will have some vulnerabilities in your software and/or its dependencies. The thing that’s important to realize though is that software can contain components with vulnerabilities and yet not be vulnerable itself. This is where Vulnerability Exploitability eXchange (VEX) comes in. It’s a machine-readable file that can be used by producers to convey information about the actual “exploitability” of each vulnerability and prioritize remediation, and by the consumers as an input into policy controls driving their release process.\nThe file itself is based on set of assertions (impact statements) about the status of a vulnerability in specific artifact and deployment context:\nNot affected – No remediation is required regarding this vulnerability. Affected – Actions are recommended to remediate or address this vulnerability. Fixed – Represents that these product versions contain a fix for the vulnerability. Under Investigation – Still looking whether this artifact is affected by this vulnerability. Somewhat early days for VEX, so there isn’t yet a well-formalized standard or many OSS tools. Still, A couple of interesting initiatives in this space worth keeping an eye on:\nCycloneDX 1.4 - This version of the CycloneDX SBOM format adds support for VEX’d vulnerabilities. This embedded VEX provides a single artifact that describes both inventory and VEX data. OpenVEX is a minimal (but compliant) implementation of the VEX format optimized for interoperability. OpenVex includes spec, and a growing ecosystem of tools (Go, .NET, Rest). Conclusion Hope this post helped you identify at least one thing you can do in your software release pipeline to increase its supply chain security.\n","wordCount":"1145","inLanguage":"en","image":"https://blog.chmarny.com/images/site-feature-image.png","datePublished":"2023-06-14T08:57:57-07:00","dateModified":"2023-06-14T08:57:57-07:00","author":{"@type":"Person","name":"Mark Chmarny"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chmarny.com/posts/provenance-transparency-context-3-aspects-of-s3c-you-can-implement-today/"},"publisher":{"@type":"Organization","name":"Mark Chmarny","logo":{"@type":"ImageObject","url":"https://blog.chmarny.com/favicons/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://blog.chmarny.com/ accesskey=h title="Mark Chmarny (Alt + H)">Mark Chmarny</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chmarny.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://blog.chmarny.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.chmarny.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.chmarny.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.chmarny.com/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.chmarny.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.chmarny.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Provenance, transparency, and context, the three aspects of software supply chain security you can implement today</h1><div class=post-meta><span title='2023-06-14 08:57:57 -0700 -0700'>2023-06-14</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>Mark Chmarny</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#provenance aria-label=Provenance>Provenance</a></li><li><a href=#transparency aria-label=Transparency>Transparency</a></li><li><a href=#context aria-label=Context>Context</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>The practice of Secure Software Supply Chain (S3C) can get complex at times. Fortunately though, a large portion of the key things we can do to secure our software delivery pipelines are actually pretty easy. This post covers three concepts you can implement today:</p><ul><li><strong>provenance</strong> - Where and how was the software created? Using what source code, tools, and build system? Who were the individuals involved in its development?</li><li><strong>transparency</strong> - What’s in the software artifact? What are the packages, libraries, and their versions? Who provided them? And, what are the relationships between them? (what depends on, uses, what)</li><li><strong>context</strong> - What are the vulnerabilities, and what is their potential exploitability in that specific artifact?</li></ul><p>Let&rsquo;s review each one of these and provide some options on how to implement them in your software release pipeline.</p><h1 id=provenance>Provenance<a hidden class=anchor aria-hidden=true href=#provenance>#</a></h1><p>The open source community under OpenSSF has created a security framework for how we can think of build provenance. This framework is called <a href=https://slsa.dev/>Supply Chain Levels for Software Artifacts</a> (SLSA). it provides a standardized check-list of controls to improve the integrity, prevent tampering, and secure software artifacts and build infrastructure.</p><p>At its core, SLSA is based on the builders producing conformant and signed provenance documents (aka build attestation). The provenance document includes Build Definition (e.g. parameters, dependencies), and Run Details (e.g. builder, metadata). And, to make it easier for us to reason about it, the key characteristics of the build provenance are grouped into SLSA Levels (1-3). The downstream consumers of the produced artifacts can inspect the provenance, and base their policy decisions on the inferred level of SLSA. More about SLSA levels on <a href=https://slsa.dev/spec/v1.0/about>slsa.dev</a>.</p><p>Add SLSA-based build provenance to your release pipeline:</p><ul><li><a href=https://cloud.google.com/build/docs/securing-builds/view-build-provenance>Google Cloud Build</a> - Level 3 assurance automatically generated in Artifact Analysis for all images pushed to Artifact Registry</li><li><a href=https://github.com/slsa-framework/slsa-github-generator>GitHub Actions</a> - Reusable workflow, which when added to your release pipeline generates Level 3 build provenance</li><li><a href=https://about.gitlab.com/blog/2022/11/30/achieve-slsa-level-2-compliance-with-gitlab/>GitLab CI/CD</a> - Runner which can generate artifact metadata meeting SLSA Level 2 with support for external code signer to potentially deliver Level 3.</li></ul><blockquote><p>Regardless of the means by which SLSA provenance was generated, you can use the <a href=https://github.com/slsa-framework/slsa-verifier>SLSA Verifier CLI</a> to ensure its validity.</p></blockquote><h1 id=transparency>Transparency<a hidden class=anchor aria-hidden=true href=#transparency>#</a></h1><p>While SLSA is about how the software was produced, Software Bill of Materials (SBOM) is about what&rsquo;s in the software. Think of SBOM like an ingredients label on a can of food you buy in the grocery store. It&rsquo;s an inventory of all the components that make up the software. SBOMs are used during the production of software (e.g. license compliance), during process of software selection (e.g. policy compliance), or during operations (e.g. risk management). SBOMs can be also used in all three of these use-cases for vulnerability monitoring as new vulnerabilities are discovered all the time. More about SBOM and the related US regulation on <a href=https://www.cisa.gov/sbom>cisa.gov/sbom</a>. Similar regulations apply in the <a href=https://www.europarl.europa.eu/thinktank/en/document/EPRS_BRI(2021)689333>EU</a> and the <a href=https://www.nist.gov/system/files/documents/2022/05/11/Guidance%20on%20Software%20Supply%20Chain%20Security_EO14028%20Sections%204c_4d%5B71%5D.pdf>UK</a>. While there is many formats/flavors of SBOM, the most common open standards today are:</p><ul><li>SPDX (Software Package Data Exchange) - Provides a structured format for documenting software components, licenses, copyrights, and security vulnerabilities, including information about packages, files, and relationships. It&rsquo;s maintained by the Linux Foundation (LF), and it has a broader ecosystem of tools and libraries which can make it easier to integrate into your pipeline. Given the extensive set of fields and options, SPDX can get complex for humans to reason about though.</li><li>CycloneDX - Provides a lightweight and flexible representation of the components and dependencies, including details about packages, versions, licenses, and vulnerability information, allowing for interoperability between different tools and platforms. CycloneDX allows for extensibility (see VEX section below). However, unlike SPDX, CycloneDX is not an industry-standard format, and while it has gained traction and adoption, it may not enjoy the same level of standardization and industry-wide acceptance as SPDX.</li></ul><p>Ultimately, the choice between SPDX and CycloneDX depends on your specific needs, the ecosystem you operate in, and the level of standardization and extensibility required for your software supply chain management.</p><p>You can add SBOM to your release pipeline in a number of ways:</p><ul><li><strong>Using Lockfile</strong> - These SBOMs are generated using the information in language specific lockfile (e.g. go.mod, gradle.lockfile, or pom.xml). Sometimes they are generated by your Source Code Management System (e.g. <a href=https://github.blog/2023-03-28-introducing-self-service-sboms/>GitHub SBOM</a>). While easy, this approach does not account only for the user defined code, and lacks information about the base image on which this code will be deployed. Lockfile-based SBOMs don&rsquo;t work well also for repos which build to more than one artifact.</li><li><strong>During Build</strong> - Generating SBOMs during build is not very common yet. For the Go ecosystem, there is <a href=https://github.com/ko-build/ko>ko</a>, and for Java <a href=https://github.com/CycloneDX/cyclonedx-maven-plugin>Maven using the CycloneDX plugin</a>. The benefit of this approach is build tools have a deep understanding of the dependencies, and the SBOM generation becomes this way an inherent part of the build workflow, ensuring consistency with each build (e.g. format)</li><li><strong>From Container</strong> - These SBOMs are generated from the final product. This is the most common approach to generating SBOMs today (e.g. using OSS tools like <a href=https://github.com/anchore/syft>syft</a> or <a href=https://github.com/snyk/cli>snyk</a>). The reliance on the layered file systems or container image may result in an incomplete view of all the dependencies, especially with transitive dependencies and in situations when not installed using package manager.</li></ul><h1 id=context>Context<a hidden class=anchor aria-hidden=true href=#context>#</a></h1><p>Unless you are building a simple hello world application, chances are high you will have some vulnerabilities in your software and/or its dependencies. The thing that&rsquo;s important to realize though is that software can contain components with vulnerabilities and yet not be vulnerable itself. This is where <a href=https://www.cisa.gov/sites/default/files/publications/VEX_Use_Cases_Document_508c.pdf>Vulnerability Exploitability eXchange</a> (VEX) comes in. It&rsquo;s a machine-readable file that can be used by producers to convey information about the actual &ldquo;exploitability&rdquo; of each vulnerability and prioritize remediation, and by the consumers as an input into policy controls driving their release process.</p><p>The file itself is based on set of assertions (impact statements) about the status of a
vulnerability in specific artifact and deployment context:</p><ul><li><code>Not affected</code> – No remediation is required regarding this vulnerability.</li><li><code>Affected</code> – Actions are recommended to remediate or address this vulnerability.</li><li><code>Fixed</code> – Represents that these product versions contain a fix for the vulnerability.</li><li><code>Under Investigation</code> – Still looking whether this artifact is affected by
this vulnerability.</li></ul><p>Somewhat early days for VEX, so there isn&rsquo;t yet a well-formalized standard or many OSS tools. Still, A couple of interesting initiatives in this space worth keeping an eye on:</p><ul><li><a href=https://cyclonedx.org/capabilities/vex/>CycloneDX 1.4</a> - This version of the CycloneDX SBOM format adds support for VEX&rsquo;d vulnerabilities. This embedded VEX provides a single artifact that describes both inventory and VEX data.</li><li><a href=https://github.com/openvex>OpenVEX</a> is a minimal (but compliant) implementation of the VEX format optimized for interoperability. OpenVex includes spec, and a growing ecosystem of tools (<a href=https://github.com/openvex/go-vex>Go</a>, <a href=https://github.com/JamieMagee/openvex.net>.NET</a>, <a href=https://docs.rs/openvex/latest/openvex/>Rest</a>).</li></ul><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>Hope this post helped you identify at least one thing you can do in your software release pipeline to increase its supply chain security.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chmarny.com/tags/s3c/>S3c</a></li><li><a href=https://blog.chmarny.com/tags/cve/>Cve</a></li><li><a href=https://blog.chmarny.com/tags/slsa/>Slsa</a></li><li><a href=https://blog.chmarny.com/tags/sbom/>Sbom</a></li><li><a href=https://blog.chmarny.com/tags/vex/>Vex</a></li></ul><nav class=paginav><a class=prev href=https://blog.chmarny.com/posts/leaving-cruise/><span class=title>« Prev</span><br><span>Leaving Cruise; why I'm still excited about AI platforms</span>
</a><a class=next href=https://blog.chmarny.com/posts/automating-software-supply-chain-security/><span class=title>Next »</span><br><span>Software supply chain data fatigue and what I’ve learned from SBOM, vulnerability reports</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://blog.chmarny.com/>Mark Chmarny</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>