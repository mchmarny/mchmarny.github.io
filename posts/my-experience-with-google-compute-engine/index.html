<!doctype html><html lang=en dir=auto data-theme=dark><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>My experience with Google Compute Engine | Mark Chmarny</title><meta name=keywords content="gce,gcp,google,cloud,tool,cli"><meta name=description content="As part of my recent solution review, I wanted to compare a few performance metrics specific to multi-node data service deployment on different clouds. This post is about my experience with Google Compute Engine (GCE) as part of that evaluation."><meta name=author content="Mark Chmarny"><link rel=canonical href=https://blog.chmarny.com/posts/my-experience-with-google-compute-engine/><link crossorigin=anonymous href=/assets/css/stylesheet.5bef4b698d33ee9d58f22269d129fe3c725b1b3356a4ed1ded10651b773f88c5.css integrity="sha256-W+9LaY0z7p1Y8iJp0Sn+PHJbGzNWpO0d7RBlG3c/iMU=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chmarny.com/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chmarny.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chmarny.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chmarny.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.chmarny.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chmarny.com/posts/my-experience-with-google-compute-engine/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><meta property="og:url" content="https://blog.chmarny.com/posts/my-experience-with-google-compute-engine/"><meta property="og:site_name" content="Mark Chmarny"><meta property="og:title" content="My experience with Google Compute Engine"><meta property="og:description" content="As part of my recent solution review, I wanted to compare a few performance metrics specific to multi-node data service deployment on different clouds. This post is about my experience with Google Compute Engine (GCE) as part of that evaluation."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-04-03T00:36:38+00:00"><meta property="article:modified_time" content="2016-04-03T00:36:38+00:00"><meta property="article:tag" content="Gce"><meta property="article:tag" content="Gcp"><meta property="article:tag" content="Google"><meta property="article:tag" content="Cloud"><meta property="article:tag" content="Tool"><meta property="article:tag" content="Cli"><meta property="og:image" content="https://blog.chmarny.com/images/site-feature-image.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.chmarny.com/images/site-feature-image.png"><meta name=twitter:title content="My experience with Google Compute Engine"><meta name=twitter:description content="As part of my recent solution review, I wanted to compare a few performance metrics specific to multi-node data service deployment on different clouds. This post is about my experience with Google Compute Engine (GCE) as part of that evaluation."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chmarny.com/posts/"},{"@type":"ListItem","position":2,"name":"My experience with Google Compute Engine","item":"https://blog.chmarny.com/posts/my-experience-with-google-compute-engine/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"My experience with Google Compute Engine","name":"My experience with Google Compute Engine","description":"As part of my recent solution review, I wanted to compare a few performance metrics specific to multi-node data service deployment on different clouds. This post is about my experience with Google Compute Engine (GCE) as part of that evaluation.\n","keywords":["gce","gcp","google","cloud","tool","cli"],"articleBody":"As part of my recent solution review, I wanted to compare a few performance metrics specific to multi-node data service deployment on different clouds. This post is about my experience with Google Compute Engine (GCE) as part of that evaluation.\nAPI \u0026 Tools When targeting developers, API and surrounding tooling is an absolute must. The ability to easily manage and automate cloud resources is something that developers demand. Their usage patterns require efficiency, which at that level, comes mainly from automation.\nHere are three specific areas that set GCE apart from others. Remember, it is not that other providers do not have these (which in many cases they do not) but rather about how clean, explicit and simple GCE implementation is in these areas.\nREST Interface One of the benefits of REST as a cloud management interface is its consistent approach to provisioning and management of resources. To manage GCE, clients send authenticated requests to perform a particular action: provision network, create instances, associate disks, etc.\nOne of the nice GCE touches in assisting programmatic implementation is that the GUI interface to Cloud Console exposes REST and command line equivalent for each operation. This allows developers to simply copy the defined operation and use it in their automation tools to remove guesswork from the initial message format creation.\nCommand-line tool gcutil is a command-line tool designed to help with management of GCE resources. Written in Python, gcutil runs natively on any UNIX-based OS or under Cygwin on Windows. The important thing to realize here is that while gcutil is a command-line tool; it still uses the same REST interface to message its commands to GCE.\nOne of the things that I often long for in cloud management APIs is support for multiple personas. With gcutil it is as simple as providing an existent credential file (--credentials_file). This way separating accounts is just a runtime flag away.\nWhat makes gcutil really user-friendly for developers however is its ability to set default values for common operations. By caching values of common commands (--cache_flag_values), gcutil can reuse arguments like --zone or --machine_type across multiple commands.\nPerhaps the part that makes gcutil most unique though is its ability to perform each command in either synchronous or asynchronous mode. By default, gcutil waits for each command to complete before moving returning control. In asynchronous mode, however, gcutil returns request id immediately after posting the request. This was a massive feature for me when testing number of cluster node discovery strategies.\nThese features combined with the ability to customize result format per each command: JSON, CSV, Table as well as the ability to return only the name of the newly created resources which allows for piping results from one command as on input to another, make gcutil one of the best though-through IaaS clients I’d ever seen.\nSpeed \u0026 Flexibility In my short experience, I found instances and disk (yes, not “volumes”) provisioning as well as general instance startup on GCE to be fast. My specific interest was the time that it took to spin, configuring and terminating entire clusters of data nodes. In that specific use-case, CGE was faster than EC2, Azure or Rackspace.\nThe project metaphor, while somewhat awkward for me initially, quickly became for me a clear separation for distinct areas of work. Additionally, its integration with the advanced routing features allowed me to easily create gateway servers (aka VPN) to span clusters across local and GCE network.\nFor me personally, perhaps the biggest feature was the metadata support. In addition to the basic key value pair tags, every GCE instance also supports metadata. In addition to including information defined by the service itself like instance host name, it can also include user-defined data.\ngcutil addinstance node-${NODE_COUNT}\" \\ --metadata=\"cluster:${CLUSTER_NAME}\" \\ --metadata=\"index:${NODE_COUNT}\" ... Update: gcutil is now deprecated in favour of gcloud compute. More info on transitioning here.\nInstance configuration, as well as the configuration of other instances in the same project, is available in a form of a REST query against the provisioned metadata server. This metadata can also include project-level metadata.\nThe place where this capability really came handy for me was node-level metadata. By simply defining metadata value for a node index, I was able to have individual data nodes define their own unique cluster names (–metadata=name:node-0) as well as query the project-level data for cluster name.\nCustom metadata becomes especially useful when using startup scripts to execute during instance boot. Using gcutil, I was able to pass in a single local startup scripts using the –metadata_from_file flag and have it discover its variables from metadata parameters.\nNODE_INDEX=$(curl http://metadata/computeMetadata/v1beta1/instance/attributes/index) Pricing In my particular test cycles, I must have deployed close to 1000 individual instances across EC2 and GCE. Each one of these instances stayed up for maximum 15–20 minutes, just enough to run a set of tests on the new cluster. The part that makes GCE a lot more compelling for these kinds of use-cases is the granular pricing. Google prices its instances in one-minute increments with 10-minute minimum; not hourly, like EC2.\nOne area where GCE is perhaps not as flexible as I would like is in the area of billing. I do like the flexibility to charge individual projects to different credit cards, but would like to see a consolidated billing option there too. Also, this is the one area that is not supported by the API!\nGCE seems like a fundamentally different type of IaaS, designed specifically with developers in mind. While probably not much of a challenge to EC2 anytime soon, over time though, provided they augment their service offering list, GCE’s focus on developers will pay off. Having experienced their tools first hand, it is clear these guys know how to run infrastructure at a massive scale without alienating developers.\n","wordCount":"964","inLanguage":"en","image":"https://blog.chmarny.com/images/site-feature-image.png","datePublished":"2016-04-03T00:36:38.497Z","dateModified":"2016-04-03T00:36:38.497Z","author":{"@type":"Person","name":"Mark Chmarny"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chmarny.com/posts/my-experience-with-google-compute-engine/"},"publisher":{"@type":"Organization","name":"Mark Chmarny","logo":{"@type":"ImageObject","url":"https://blog.chmarny.com/favicons/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://blog.chmarny.com/ accesskey=h title="Mark Chmarny (Alt + H)">Mark Chmarny</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chmarny.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://blog.chmarny.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.chmarny.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.chmarny.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.chmarny.com/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.chmarny.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.chmarny.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">My experience with Google Compute Engine</h1><div class=post-meta><span title='2016-04-03 00:36:38.497 +0000 UTC'>2016-04-03</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>Mark Chmarny</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#api--tools aria-label="API & Tools">API & Tools</a></li><li><a href=#rest-interface aria-label="REST Interface">REST Interface</a></li><li><a href=#command-line-tool aria-label="Command-line tool">Command-line tool</a></li><li><a href=#speed--flexibility aria-label="Speed & Flexibility">Speed & Flexibility</a></li><li><a href=#pricing aria-label=Pricing>Pricing</a></li></ul></div></details></div><div class=post-content><p>As part of my recent solution review, I wanted to compare a few performance metrics specific to multi-node data service deployment on different clouds. This post is about my experience with Google Compute Engine (GCE) as part of that evaluation.</p><h2 id=api--tools>API & Tools<a hidden class=anchor aria-hidden=true href=#api--tools>#</a></h2><p>When targeting developers, API and surrounding tooling is an absolute must. The ability to easily manage and automate cloud resources is something that developers demand. Their usage patterns require efficiency, which at that level, comes mainly from automation.</p><p><img loading=lazy src=/images/0__qWIUIOx8bVDiHcvr.png></p><p>Here are three specific areas that set GCE apart from others. Remember, it is not that other providers do not have these (which in many cases they do not) but rather about how clean, explicit and simple GCE implementation is in these areas.</p><h2 id=rest-interface>REST Interface<a hidden class=anchor aria-hidden=true href=#rest-interface>#</a></h2><p>One of the benefits of REST as a cloud management interface is its consistent approach to provisioning and management of resources. To manage GCE, clients send authenticated requests to perform a particular action: provision network, create instances, associate disks, etc.</p><p>One of the nice GCE touches in assisting programmatic implementation is that the GUI interface to Cloud Console exposes REST and command line equivalent for each operation. This allows developers to simply copy the defined operation and use it in their automation tools to remove guesswork from the initial message format creation.</p><h2 id=command-line-tool>Command-line tool<a hidden class=anchor aria-hidden=true href=#command-line-tool>#</a></h2><p>gcutil is a command-line tool designed to help with management of GCE resources. Written in Python, gcutil runs natively on any UNIX-based OS or under Cygwin on Windows. The important thing to realize here is that while gcutil is a command-line tool; it still uses the same REST interface to message its commands to GCE.</p><p>One of the things that I often long for in cloud management APIs is support for multiple personas. With gcutil it is as simple as providing an existent credential file (<code>--credentials_file</code>). This way separating accounts is just a runtime flag away.</p><p>What makes gcutil really user-friendly for developers however is its ability to set default values for common operations. By caching values of common commands (<code>--cache_flag_values</code>), gcutil can reuse arguments like <code>--zone</code> or <code>--machine_type</code> across multiple commands.</p><p>Perhaps the part that makes gcutil most unique though is its ability to perform each command in either synchronous or asynchronous mode. By default, gcutil waits for each command to complete before moving returning control. In asynchronous mode, however, gcutil returns request id immediately after posting the request. This was a massive feature for me when testing number of cluster node discovery strategies.</p><p>These features combined with the ability to customize result format per each command: JSON, CSV, Table as well as the ability to return only the name of the newly created resources which allows for piping results from one command as on input to another, make gcutil one of the best though-through IaaS clients I’d ever seen.</p><h2 id=speed--flexibility>Speed & Flexibility<a hidden class=anchor aria-hidden=true href=#speed--flexibility>#</a></h2><p>In my short experience, I found instances and disk (yes, not &ldquo;volumes&rdquo;) provisioning as well as general instance startup on GCE to be fast. My specific interest was the time that it took to spin, configuring and terminating entire clusters of data nodes. In that specific use-case, CGE was faster than EC2, Azure or Rackspace.</p><p>The project metaphor, while somewhat awkward for me initially, quickly became for me a clear separation for distinct areas of work. Additionally, its integration with the advanced routing features allowed me to easily create gateway servers (aka VPN) to span clusters across local and GCE network.</p><p><img loading=lazy src=/images/0__UuyJJYtJuX6MBDan.png></p><p>For me personally, perhaps the biggest feature was the metadata support. In addition to the basic key value pair tags, every GCE instance also supports metadata. In addition to including information defined by the service itself like instance host name, it can also include user-defined data.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>gcutil addinstance node-<span class=si>${</span><span class=nv>NODE_COUNT</span><span class=si>}</span><span class=s2>&#34; \
</span></span></span><span class=line><span class=cl><span class=s2>  --metadata=&#34;</span>cluster:<span class=si>${</span><span class=nv>CLUSTER_NAME</span><span class=si>}</span><span class=s2>&#34; \
</span></span></span><span class=line><span class=cl><span class=s2>  --metadata=&#34;</span>index:<span class=si>${</span><span class=nv>NODE_COUNT</span><span class=si>}</span><span class=s2>&#34; ...
</span></span></span></code></pre></div><blockquote><p>Update: <code>gcutil</code> is now deprecated in favour of <code>gcloud compute</code>. More info on transitioning <a href=https://cloud.google.com/compute/docs/gcloud-compute/transition-gcloud-gcutil>here</a>.</p></blockquote><p>Instance configuration, as well as the configuration of other instances in the same project, is available in a form of a REST query against the provisioned metadata server. This metadata can also include project-level metadata.</p><p>The place where this capability really came handy for me was node-level metadata. By simply defining metadata value for a node index, I was able to have individual data nodes define their own unique cluster names (<code>–metadata=name:node-0</code>) as well as query the project-level data for cluster name.</p><p>Custom metadata becomes especially useful when using startup scripts to execute during instance boot. Using gcutil, I was able to pass in a single local startup scripts using the <code>–metadata_from_file</code> flag and have it discover its variables from metadata parameters.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>NODE_INDEX</span><span class=o>=</span><span class=k>$(</span>curl http://metadata/computeMetadata/v1beta1/instance/attributes/index<span class=k>)</span>
</span></span></code></pre></div><h2 id=pricing>Pricing<a hidden class=anchor aria-hidden=true href=#pricing>#</a></h2><p>In my particular test cycles, I must have deployed close to 1000 individual instances across EC2 and GCE. Each one of these instances stayed up for maximum 15–20 minutes, just enough to run a set of tests on the new cluster. The part that makes GCE a lot more compelling for these kinds of use-cases is the granular pricing. Google prices its instances in one-minute increments with 10-minute minimum; not hourly, like EC2.</p><p>One area where GCE is perhaps not as flexible as I would like is in the area of billing. I do like the flexibility to charge individual projects to different credit cards, but would like to see a consolidated billing option there too. Also, this is the one area that is not supported by the API!</p><p>GCE seems like a fundamentally different type of IaaS, designed specifically with developers in mind. While probably not much of a challenge to EC2 anytime soon, over time though, provided they augment their service offering list, GCE’s focus on developers will pay off. Having experienced their tools first hand, it is clear these guys know how to run infrastructure at a massive scale without alienating developers.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chmarny.com/tags/gce/>Gce</a></li><li><a href=https://blog.chmarny.com/tags/gcp/>Gcp</a></li><li><a href=https://blog.chmarny.com/tags/google/>Google</a></li><li><a href=https://blog.chmarny.com/tags/cloud/>Cloud</a></li><li><a href=https://blog.chmarny.com/tags/tool/>Tool</a></li><li><a href=https://blog.chmarny.com/tags/cli/>Cli</a></li></ul><nav class=paginav><a class=prev href=https://blog.chmarny.com/posts/vision-of-smarter-thingz-project-in-adaptive-metric-flow-modeling/><span class=title>« Prev</span><br><span>Vision of smarter thingz - project in adaptive metric flow modeling</span>
</a><a class=next href=https://blog.chmarny.com/posts/thinking-big-about-data-at-intel/><span class=title>Next »</span><br><span>Thinking Big about Data at Intel</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://blog.chmarny.com/>Mark Chmarny</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>