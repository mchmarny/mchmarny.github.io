<!doctype html><html lang=en dir=auto data-theme=dark><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Reproducible OpenID connect to GCR for GitHub Actions workflows using Terraform | Mark Chmarny</title><meta name=keywords content="gcp,github,oidc,workflow,terraform"><meta name=description content="The recently introduced by GitHub support for OpenID Connect (OIDC) tokens in GitHub Actions allows workflows to mint new tokens and then exchange those tokens for short-lived OAuth 2.0 or JWT tokens. These tokens can be used to access and manage Cloud resources. This is all done without the need to store the traditional long-lived service account keys in a form of GitHub secrets."><meta name=author content="Mark Chmarny"><link rel=canonical href=https://blog.chmarny.com/posts/reproducible-github-workflow-openid-connect-for-gcp-using-terraform/><link crossorigin=anonymous href=/assets/css/stylesheet.5bef4b698d33ee9d58f22269d129fe3c725b1b3356a4ed1ded10651b773f88c5.css integrity="sha256-W+9LaY0z7p1Y8iJp0Sn+PHJbGzNWpO0d7RBlG3c/iMU=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chmarny.com/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chmarny.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chmarny.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chmarny.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.chmarny.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chmarny.com/posts/reproducible-github-workflow-openid-connect-for-gcp-using-terraform/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><meta property="og:url" content="https://blog.chmarny.com/posts/reproducible-github-workflow-openid-connect-for-gcp-using-terraform/"><meta property="og:site_name" content="Mark Chmarny"><meta property="og:title" content="Reproducible OpenID connect to GCR for GitHub Actions workflows using Terraform"><meta property="og:description" content="The recently introduced by GitHub support for OpenID Connect (OIDC) tokens in GitHub Actions allows workflows to mint new tokens and then exchange those tokens for short-lived OAuth 2.0 or JWT tokens. These tokens can be used to access and manage Cloud resources. This is all done without the need to store the traditional long-lived service account keys in a form of GitHub secrets."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-29T16:12:38-08:00"><meta property="article:modified_time" content="2022-01-29T16:12:38-08:00"><meta property="article:tag" content="Gcp"><meta property="article:tag" content="Github"><meta property="article:tag" content="Oidc"><meta property="article:tag" content="Workflow"><meta property="article:tag" content="Terraform"><meta property="og:image" content="https://blog.chmarny.com/images/site-feature-image.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.chmarny.com/images/site-feature-image.png"><meta name=twitter:title content="Reproducible OpenID connect to GCR for GitHub Actions workflows using Terraform"><meta name=twitter:description content="The recently introduced by GitHub support for OpenID Connect (OIDC) tokens in GitHub Actions allows workflows to mint new tokens and then exchange those tokens for short-lived OAuth 2.0 or JWT tokens. These tokens can be used to access and manage Cloud resources. This is all done without the need to store the traditional long-lived service account keys in a form of GitHub secrets."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chmarny.com/posts/"},{"@type":"ListItem","position":2,"name":"Reproducible OpenID connect to GCR for GitHub Actions workflows using Terraform","item":"https://blog.chmarny.com/posts/reproducible-github-workflow-openid-connect-for-gcp-using-terraform/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Reproducible OpenID connect to GCR for GitHub Actions workflows using Terraform","name":"Reproducible OpenID connect to GCR for GitHub Actions workflows using Terraform","description":"The recently introduced by GitHub support for OpenID Connect (OIDC) tokens in GitHub Actions allows workflows to mint new tokens and then exchange those tokens for short-lived OAuth 2.0 or JWT tokens. These tokens can be used to access and manage Cloud resources. This is all done without the need to store the traditional long-lived service account keys in a form of GitHub secrets.\n","keywords":["gcp","github","oidc","workflow","terraform"],"articleBody":"The recently introduced by GitHub support for OpenID Connect (OIDC) tokens in GitHub Actions allows workflows to mint new tokens and then exchange those tokens for short-lived OAuth 2.0 or JWT tokens. These tokens can be used to access and manage Cloud resources. This is all done without the need to store the traditional long-lived service account keys in a form of GitHub secrets.\nOn Google Cloud Platform (GCP) this process uses Workload Identity Federation and enable your GitHub Actions a fine-grained access scoping using attribute mappings between the OIDC token, which by default, automatically expires one hour after it was created, to impersonate a GCP service account and access resources on Google Cloud using the designated GCP permissions.\nOIDC Complexity The problem is that setting up identity federation for GitHub Actions in any of the Cloud Service Providers (CSP) requires executing number of CLI commands, each with endless number of flags to implement the required attribute mappings between the provider access permissions and GitHub repository or username.\nIn this post I’ll outline a reproducible process of setting up Identity Federation in GCP for one of the most common use-cases in GitHub Actions, building and publishing container images.\nReproducible Setup Each execution of this process applies to a single GCP project and GitHub repository combination. To make this setup reproducible we’re going to use Terraform. By providing different variables during execution, we’ll be able to apply that same Terraform configuration to any other GitHub repo and GCP project combination.\nPrerequisites The prerequisites to executing this setup include:\nTerraform CLI GCP Project gcloud CLI Good how-to on using terraform with GCP is located here.\nOne-time Setup To acquire the reproducible Github Workflow OpenID Connect setup for GCP you can either clone the Repo using SSH:\ngit clone git@github.com:mchmarny/oidc-for-gcp-using-terraform.git or using HTTP:\ngit clone https://github.com/mchmarny/oidc-for-gcp-using-terraform.git Once you’ve cloned the setup repo, navigate inside of that cloned directory and initialize Terraform\nMake sure to authenticate to GCP using gcloud auth application-default login if you haven’t done it already.\nterraform init Note, this flow uses the default, local terraform state. Make sure you do not check the state files into your source control (see .gitignore), or consider using a persistent state provider like GCS.\nExecuting Configuration To configure Github Workflow OpenID Connect setup for GCP apply the cloned configuration:\nterraform apply When promoted, provide the 2 required variables:\nproject_id is the GCP project ID (not the name) which you want to target from your GitHub Action. git_repo is the username/repo combination in which you GitHub Actions will be executing What Included You can review each one of the *.tf files for content. When you confirm yes at the final prompt, the main artifacts created by this setup in the GCP project defined by the project_id variable include:\nEnablement of the required GCP APIs servicecontrol.googleapis.com containerregistry.googleapis.com iam.googleapis.com iamcredentials.googleapis.com servicemanagement.googleapis.com storage-api.googleapis.com Creation of github-actions-user service account which the GitHub Action will impersonate when publishing images into GCR, and binding that account to the two required role: roles/storage.objectCreator roles/storage.objectViewer Creation of the workload identity pool: github-pool, and GitHub repo-level pool provider: github-provider Finally, creation of the IAM policy bindings to the service account resources created by GitHub identify for the specific GitHub repository defined by the git_repo variable Repo Configuration The result each execution of the above defined configuration will include 3 GitHub repo configuration properties:\nPROJECT_ID which is the project ID in which you setup the workload identity federation SERVICE_ACCOUNT which is the IAM service account your GitHub Action workflows will use to push images into GCR (e.g. github-action-publisher@.iam.gserviceaccount.com) IDENTITY_PROVIDER which is the workflow identity provider ID you must use lng with the above service account to connect to GCP (e.g. projects//locations/global/workloadIdentityPools/github-pool/providers/github-provider) Depending on your tolerance, you may be OK using all 3 of these parameters in your GitHub Actions workflow in plain-text. In most cases, however, you will probably create GitHubsecrets in your repository to inject them into your workflow at runtime.\nGitHub Workflow Configuration With the Workload Identity Federation configured yur workflow can now establish delegated trust relationships to the narrowly scoped set of permissions in GCP. The google-github-actions/auth includes many examples using gcloud in your workflow.\nIn this post I’m going to focus on Go-specific configuration using ko, (a super simple and fast container image builder for Go apps) to build and publish images into GCR. The full workflow is available here. The key steps include:\nPush Job First, in order to create OIDC tokens, the GitHub Actions will need additional permissions. In addition to regular content read, the workflow will also id-token write.\njobs: push: runs-on: ubuntu-latest permissions: contents: read id-token: write steps: GCP Authentication In order to push images to GCR, the workflow will need to first authenticate to GCP. Google has an action just for that that can be configured to generate OAuth 2.0 Access Token. To do this you will need to set the token_format to access_token. Additionally, this step will use the workload identity provider and service account secrets we configured above:\n- id: auth name: Get GCP token uses: google-github-actions/auth@v0.5.0 with: token_format: \"access_token\" workload_identity_provider: ${{ secrets.IDENTITY_PROVIDER }} service_account: ${{ secrets.SERVICE_ACCOUNT }} Install And Login Ko Ko is the fastest way of creating container images in Go without Docker. All we need to do is install it and login to GCR with the access token created by the auth step above:\n- name: Install Ko uses: imjasonh/setup-ko@v0.4 with: version: tip - name: Login With ko run: | ko login gcr.io --username=oauth2accesstoken --password=${{ steps.auth.outputs.access_token }} Publish Image With ko logged in, now you can build and publish the image. A few things to highlight here. ko build (pka publish) will build and publish container images from the given path. The --image-refs flag will output the digest of the published image to the provided file, and the --bare allows us to define the full image URL using the KO_DOCKER_REPO environment variable.\nIn addition to this we will set the previously exported RELEASE_VERSION environment variable to both version field in the main.go file and set it as a tag on the image.\n- name: Publish Image run: | ko build ./cmd/ --image-refs ./image-digest --bare --tags ${{ env.RELEASE_VERSION }},latest env: KO_DOCKER_REPO: gcr.io/${{ secrets.PROJECT_ID }}/restme GOFLAGS: \"-ldflags=-X=main.version=${{ env.RELEASE_VERSION }}\" Sign Image Once the image is published, we can also sign and verify the published image in GCR using cosign.\n- name: Install Cosign uses: sigstore/cosign-installer@main with: cosign-release: v1.4.1 The benefit of combining ko and cosign is that we can use the image digest output into a local file by ko by providing its path using --force flag in the cosign sign command.\nWith the v1.4 release of cosign, you set th COSIGN_EXPERIMENTAL variable to push the data into GCR.\n- name: Sign Image run: | cosign sign --force $(cat ./image-digest) env: COSIGN_EXPERIMENTAL: 1 Summary Hope you find this helpful. The Terraform configuration is available in my oidc-for-gcp-using-terraform repo, and you can find a fully functional example fo the image-on-git-tag GitHub Actions workflow in my restme repo.\n","wordCount":"1163","inLanguage":"en","image":"https://blog.chmarny.com/images/site-feature-image.png","datePublished":"2022-01-29T16:12:38-08:00","dateModified":"2022-01-29T16:12:38-08:00","author":{"@type":"Person","name":"Mark Chmarny"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chmarny.com/posts/reproducible-github-workflow-openid-connect-for-gcp-using-terraform/"},"publisher":{"@type":"Organization","name":"Mark Chmarny","logo":{"@type":"ImageObject","url":"https://blog.chmarny.com/favicons/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://blog.chmarny.com/ accesskey=h title="Mark Chmarny (Alt + H)">Mark Chmarny</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.chmarny.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://blog.chmarny.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.chmarny.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.chmarny.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.chmarny.com/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.chmarny.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.chmarny.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Reproducible OpenID connect to GCR for GitHub Actions workflows using Terraform</h1><div class=post-meta><span title='2022-01-29 16:12:38 -0800 -0800'>2022-01-29</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>Mark Chmarny</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#oidc-complexity aria-label="OIDC Complexity">OIDC Complexity</a></li><li><a href=#reproducible-setup aria-label="Reproducible Setup">Reproducible Setup</a><ul><li><a href=#prerequisites aria-label=Prerequisites>Prerequisites</a></li><li><a href=#one-time-setup aria-label="One-time Setup">One-time Setup</a></li><li><a href=#executing-configuration aria-label="Executing Configuration">Executing Configuration</a></li></ul></li><li><a href=#what-included aria-label="What Included">What Included</a></li><li><a href=#repo-configuration aria-label="Repo Configuration">Repo Configuration</a></li><li><a href=#github-workflow-configuration aria-label="GitHub Workflow Configuration">GitHub Workflow Configuration</a><ul><li><a href=#push-job aria-label="Push Job">Push Job</a></li><li><a href=#gcp-authentication aria-label="GCP Authentication">GCP Authentication</a></li><li><a href=#install-and-login-ko aria-label="Install And Login Ko">Install And Login Ko</a></li><li><a href=#publish-image aria-label="Publish Image">Publish Image</a></li><li><a href=#sign-image aria-label="Sign Image">Sign Image</a></li></ul></li><li><a href=#summary aria-label=Summary>Summary</a></li></ul></div></details></div><div class=post-content><p>The recently introduced by GitHub support for <a href=https://openid.net/connect/>OpenID Connect</a> (OIDC) tokens in <a href=https://github.com/features/actions>GitHub Actions</a> allows workflows to mint new tokens and then exchange those tokens for short-lived OAuth 2.0 or JWT tokens. These tokens can be used to access and manage Cloud resources. This is all done without the need to store the traditional long-lived service account keys in a form of GitHub secrets.</p><p>On <a href=https://cloud.google.com/>Google Cloud Platform</a> (GCP) this process uses <a href=https://cloud.google.com/iam/docs/configuring-workload-identity-federation#github-actions>Workload Identity Federation</a> and enable your GitHub Actions a fine-grained access scoping using attribute mappings between the OIDC token, which by default, automatically expires one hour after it was created, to <a href=https://cloud.google.com/iam/docs/impersonating-service-accounts>impersonate a GCP service account</a> and access resources on Google Cloud using the designated GCP permissions.</p><h2 id=oidc-complexity>OIDC Complexity<a hidden class=anchor aria-hidden=true href=#oidc-complexity>#</a></h2><p>The problem is that setting up identity federation for GitHub Actions in any of the Cloud Service Providers (CSP) requires executing number of CLI commands, each with endless number of flags to implement the required attribute mappings between the provider access permissions and GitHub repository or username.</p><p>In this post I&rsquo;ll outline a reproducible process of setting up Identity Federation in GCP for one of the most common use-cases in GitHub Actions, building and publishing container images.</p><h2 id=reproducible-setup>Reproducible Setup<a hidden class=anchor aria-hidden=true href=#reproducible-setup>#</a></h2><p>Each execution of this process applies to a single GCP project and GitHub repository combination. To make this setup reproducible we&rsquo;re going to use Terraform. By providing different variables during execution, we’ll be able to apply that same Terraform configuration to any other GitHub repo and GCP project combination.</p><h3 id=prerequisites>Prerequisites<a hidden class=anchor aria-hidden=true href=#prerequisites>#</a></h3><p>The prerequisites to executing this setup include:</p><ul><li><a href=https://www.terraform.io/downloads>Terraform CLI</a></li><li><a href=https://cloud.google.com/resource-manager/docs/creating-managing-projects>GCP Project</a></li><li><a href=https://cloud.google.com/sdk/gcloud>gcloud CLI</a></li></ul><blockquote><p>Good how-to on using terraform with GCP is located <a href=https://cloud.google.com/community/tutorials/getting-started-on-gcp-with-terraform>here</a>.</p></blockquote><h3 id=one-time-setup>One-time Setup<a hidden class=anchor aria-hidden=true href=#one-time-setup>#</a></h3><p>To acquire the reproducible Github Workflow OpenID Connect setup for GCP you can either clone the Repo using SSH:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git clone git@github.com:mchmarny/oidc-for-gcp-using-terraform.git
</span></span></code></pre></div><p>or using HTTP:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git clone https://github.com/mchmarny/oidc-for-gcp-using-terraform.git
</span></span></code></pre></div><p>Once you&rsquo;ve cloned the setup repo, navigate inside of that cloned directory and initialize Terraform</p><blockquote><p>Make sure to authenticate to GCP using <code>gcloud auth application-default login</code> if you haven&rsquo;t done it already.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>terraform init
</span></span></code></pre></div><blockquote><p>Note, this flow uses the default, local terraform state. Make sure you do not check the state files into your source control (see <code>.gitignore</code>), or consider using a persistent state provider like GCS.</p></blockquote><h3 id=executing-configuration>Executing Configuration<a hidden class=anchor aria-hidden=true href=#executing-configuration>#</a></h3><p>To configure Github Workflow OpenID Connect setup for GCP apply the cloned configuration:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>terraform apply
</span></span></code></pre></div><p>When promoted, provide the 2 required variables:</p><ul><li><code>project_id</code> is the GCP project ID (not the name) which you want to target from your GitHub Action.</li><li><code>git_repo</code> is the username/repo combination in which you GitHub Actions will be executing</li></ul><h2 id=what-included>What Included<a hidden class=anchor aria-hidden=true href=#what-included>#</a></h2><p>You can review each one of the <code>*.tf</code> files for content. When you confirm <code>yes</code> at the final prompt, the main artifacts created by this setup in the GCP project defined by the <code>project_id</code> variable include:</p><ul><li>Enablement of the required GCP APIs<ul><li><code>servicecontrol.googleapis.com</code></li><li><code>containerregistry.googleapis.com</code></li><li><code>iam.googleapis.com</code></li><li><code>iamcredentials.googleapis.com</code></li><li><code>servicemanagement.googleapis.com</code></li><li><code>storage-api.googleapis.com</code></li></ul></li><li>Creation of <code>github-actions-user</code> service account which the GitHub Action will impersonate when publishing images into GCR, and binding that account to the two required role:<ul><li><code>roles/storage.objectCreator</code></li><li><code>roles/storage.objectViewer</code></li></ul></li><li>Creation of the workload identity pool: <code>github-pool</code>, and GitHub repo-level pool provider: <code>github-provider</code></li><li>Finally, creation of the IAM policy bindings to the service account resources created by GitHub identify for the specific GitHub repository defined by the <code>git_repo</code> variable</li></ul><h2 id=repo-configuration>Repo Configuration<a hidden class=anchor aria-hidden=true href=#repo-configuration>#</a></h2><p>The result each execution of the above defined configuration will include 3 GitHub repo configuration properties:</p><ul><li><code>PROJECT_ID</code> which is the project ID in which you setup the workload identity federation</li><li><code>SERVICE_ACCOUNT</code> which is the IAM service account your GitHub Action workflows will use to push images into GCR (e.g. <code>github-action-publisher@&lt;project_id>.iam.gserviceaccount.com</code>)</li><li><code>IDENTITY_PROVIDER</code> which is the workflow identity provider ID you must use lng with the above service account to connect to GCP (e.g. <code>projects/&lt;project_number>/locations/global/workloadIdentityPools/github-pool/providers/github-provider</code>)</li></ul><blockquote><p>Depending on your tolerance, you may be OK using all 3 of these parameters in your GitHub Actions workflow in plain-text. In most cases, however, you will probably create GitHub<a href=https://docs.github.com/en/actions/security-guides/encrypted-secrets>secrets</a> in your repository to inject them into your workflow at runtime.</p></blockquote><h2 id=github-workflow-configuration>GitHub Workflow Configuration<a hidden class=anchor aria-hidden=true href=#github-workflow-configuration>#</a></h2><p>With the Workload Identity Federation configured yur workflow can now establish delegated trust relationships to the narrowly scoped set of permissions in GCP. The <a href=https://github.com/google-github-actions/auth>google-github-actions/auth</a> includes many examples using <code>gcloud</code> in your workflow.</p><p>In this post I&rsquo;m going to focus on <a href=https://go.dev/>Go</a>-specific configuration using <a href=https://github.com/google/ko>ko</a>, (a super simple and fast container image builder for Go apps) to build and publish images into <a href=https://cloud.google.com/container-registry>GCR</a>. The full workflow is available <a href=https://github.com/mchmarny/restme/blob/main/.github/workflows/image-on-tag.yaml>here</a>. The key steps include:</p><h3 id=push-job>Push Job<a hidden class=anchor aria-hidden=true href=#push-job>#</a></h3><p>First, in order to create OIDC tokens, the GitHub Actions will need additional permissions. In addition to regular <code>content</code> read, the workflow will also <code>id-token</code> write.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>push</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>permissions</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>contents</span><span class=p>:</span><span class=w> </span><span class=l>read</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>id-token</span><span class=p>:</span><span class=w> </span><span class=l>write</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span></code></pre></div><h3 id=gcp-authentication>GCP Authentication<a hidden class=anchor aria-hidden=true href=#gcp-authentication>#</a></h3><p>In order to push images to GCR, the workflow will need to first authenticate to GCP. Google has an action just for that that can be configured to generate OAuth 2.0 Access Token. To do this you will need to set the <code>token_format</code> to <code>access_token</code>. Additionally, this step will use the workload identity provider and service account secrets we configured above:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=w>    </span>- <span class=nt>id</span><span class=p>:</span><span class=w> </span><span class=l>auth</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Get GCP token</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>google-github-actions/auth@v0.5.0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>token_format</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;access_token&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>workload_identity_provider</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.IDENTITY_PROVIDER }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>service_account</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.SERVICE_ACCOUNT }}</span><span class=w>
</span></span></span></code></pre></div><h3 id=install-and-login-ko>Install And Login Ko<a hidden class=anchor aria-hidden=true href=#install-and-login-ko>#</a></h3><p>Ko is the fastest way of creating container images in Go without Docker. All we need to do is install it and login to GCR with the access token created by the <code>auth</code> step above:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Install Ko</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>imjasonh/setup-ko@v0.4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=l>tip</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Login With ko</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>        ko login gcr.io --username=oauth2accesstoken --password=${{ steps.auth.outputs.access_token }}</span><span class=w>
</span></span></span></code></pre></div><h3 id=publish-image>Publish Image<a hidden class=anchor aria-hidden=true href=#publish-image>#</a></h3><p>With ko logged in, now you can build and publish the image. A few things to highlight here. <code>ko build</code> (pka <code>publish</code>) will build and publish container images from the given path. The <code>--image-refs</code> flag will output the digest of the published image to the provided file, and the <code>--bare</code> allows us to define the full image URL using the <code>KO_DOCKER_REPO</code> environment variable.</p><p>In addition to this we will set the previously exported <code>RELEASE_VERSION</code> environment variable to both <code>version</code> field in the <code>main.go</code> file and set it as a tag on the image.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Publish Image</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>        ko build ./cmd/ --image-refs ./image-digest --bare --tags ${{ env.RELEASE_VERSION }},latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>KO_DOCKER_REPO</span><span class=p>:</span><span class=w> </span><span class=l>gcr.io/${{ secrets.PROJECT_ID }}/restme</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>GOFLAGS</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;-ldflags=-X=main.version=${{ env.RELEASE_VERSION }}&#34;</span><span class=w>
</span></span></span></code></pre></div><h3 id=sign-image>Sign Image<a hidden class=anchor aria-hidden=true href=#sign-image>#</a></h3><p>Once the image is published, we can also sign and verify the published image in GCR using <a href=https://github.com/sigstore/cosign>cosign</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Install Cosign</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>sigstore/cosign-installer@main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>cosign-release</span><span class=p>:</span><span class=w> </span><span class=l>v1.4.1</span><span class=w>
</span></span></span></code></pre></div><p>The benefit of combining <code>ko</code> and <code>cosign</code> is that we can use the image digest output into a local file by <code>ko</code> by providing its path using <code>--force</code> flag in the <code>cosign sign</code> command.</p><blockquote><p>With the v<code>1.4</code> release of cosign, you set th <code>COSIGN_EXPERIMENTAL</code> variable to push the data into GCR.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Sign Image</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>        cosign sign --force $(cat ./image-digest) </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>COSIGN_EXPERIMENTAL</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span></code></pre></div><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>Hope you find this helpful. The Terraform configuration is available in my <a href=https://github.com/mchmarny/oidc-for-gcp-using-terraform>oidc-for-gcp-using-terraform</a> repo, and you can find a fully functional example fo the image-on-git-tag GitHub Actions workflow in my <a href=https://github.com/mchmarny/restme>restme</a> repo.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chmarny.com/tags/gcp/>Gcp</a></li><li><a href=https://blog.chmarny.com/tags/github/>Github</a></li><li><a href=https://blog.chmarny.com/tags/oidc/>Oidc</a></li><li><a href=https://blog.chmarny.com/tags/workflow/>Workflow</a></li><li><a href=https://blog.chmarny.com/tags/terraform/>Terraform</a></li></ul><nav class=paginav><a class=prev href=https://blog.chmarny.com/posts/twitter-follower-activity-monitoring-using-tweethingz/><span class=title>« Prev</span><br><span>Twitter follower status monitoring made easy using TweeThingz</span>
</a><a class=next href=https://blog.chmarny.com/posts/multi-region-rest-service-on-gcp/><span class=title>Next »</span><br><span>Multi Region REST Service on GCP using GitHub Template</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://blog.chmarny.com/>Mark Chmarny</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>